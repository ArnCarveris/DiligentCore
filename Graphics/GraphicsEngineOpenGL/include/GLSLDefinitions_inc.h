"/*     Copyright 2015-2016 Egor Yusov\n"
" *  \n"
" *  Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" *  you may not use this file except in compliance with the License.\n"
" *  You may obtain a copy of the License at\n"
" * \n"
" *     http://www.apache.org/licenses/LICENSE-2.0\n"
" * \n"
" *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
" *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
" *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF ANY PROPRIETARY RIGHTS.\n"
" *\n"
" *  In no event and under no legal theory, whether in tort (including negligence), \n"
" *  contract, or otherwise, unless required by applicable law (such as deliberate \n"
" *  and grossly negligent acts) or agreed to in writing, shall any Contributor be\n"
" *  liable for any damages, including any direct, indirect, special, incidental, \n"
" *  or consequential damages of any character arising as a result of this License or \n"
" *  out of the use or inability to use the software (including but not limited to damages \n"
" *  for loss of goodwill, work stoppage, computer failure or malfunction, or any and \n"
" *  all other commercial damages or losses), even if such Contributor has been advised \n"
" *  of the possibility of such damages.\n"
" */\n"
"\n"
"#ifndef _GLSL_DEFINITIONS_\n"
"#define _GLSL_DEFINITIONS_\n"
"\n"
"#define GLSL\n"
"\n"
"#define float4 vec4\n"
"#define float3 vec3\n"
"#define float2 vec2\n"
"\n"
"#define int4 ivec4\n"
"#define int3 ivec3\n"
"#define int2 ivec2\n"
"\n"
"#define uint4 uvec4\n"
"#define uint3 uvec3\n"
"#define uint2 uvec2\n"
"\n"
"#define bool4 bvec4\n"
"#define bool3 bvec3\n"
"#define bool2 bvec2\n"
"\n"
"// OpenGL matrices in GLSL are always as column-major \n"
"// (this is not related to how they are stored)\n"
"#define float2x2 mat2x2\n"
"#define float2x3 mat3x2\n"
"#define float2x4 mat4x2\n"
"\n"
"#define float3x2 mat2x3\n"
"#define float3x3 mat3x3\n"
"#define float3x4 mat4x3\n"
"\n"
"#define float4x2 mat2x4\n"
"#define float4x3 mat3x4\n"
"#define float4x4 mat4x4\n"
"#define matrix mat4x4\n"
"\n"
"#define static\n"
"\n"
"#define SamplerState int\n"
"#define SamplerComparisonState int\n"
"\n"
"// https://www.opengl.org/wiki/Memory_Model#Incoherent_memory_access\n"
"// Shared variable access uses the rules for incoherent memory access. \n"
"// This means that the user must perform certain synchronization in \n"
"// order to ensure that shared variables are visible.\n"
"// At the same time, shared variables are all implicitly declared coherent, \n"
"// so one don\'t need to (and can\'t) use that qualifier.\n"
"#define groupshared shared\n"
"\n"
"#ifdef FRAGMENT_SHADER\n"
"#   define ddx dFdx\n"
"#   define ddy dFdy\n"
"#else\n"
"#   define ddx(x) (x) // GLSL compiler fails when it sees derivatives \n"
"#   define ddy(x) (x) // in any shader but fragment\n"
"#endif\n"
"\n"
"#define ddx_coarse ddx\n"
"#define ddy_coarse ddy\n"
"#define ddx_fine ddx\n"
"#define ddy_fine ddy\n"
"\n"
"#define mul(a, b) ((a)*(b))\n"
"#define frac fract\n"
"#define atan2 atan\n"
"#define rsqrt inversesqrt\n"
"#define fmod mod\n"
"#define lerp mix\n"
"#define dst distance\n"
"#define countbits bitCount\n"
"#define firstbithigh findMSB\n"
"#define firstbitlow findLSB\n"
"#define reversebits bitfieldReverse\n"
"\n"
"float rcp( float x ){ return 1.0 / x; }\n"
"vec2  rcp( vec2  x ){ return vec2(1.0,1.0) / x; }\n"
"vec3  rcp( vec3  x ){ return vec3(1.0,1.0,1.0) / x; }\n"
"vec4  rcp( vec4  x ){ return vec4(1.0,1.0,1.0,1.0) / x; }\n"
"\n"
"float saturate( float x ){ return clamp( x, 0.0,                      1.0 ); }\n"
"vec2  saturate( vec2  x ){ return clamp( x, vec2(0.0, 0.0),           vec2(1.0, 1.0) ); }\n"
"vec3  saturate( vec3  x ){ return clamp( x, vec3(0.0, 0.0, 0.0),      vec3(1.0, 1.0, 1.0) ); }\n"
"vec4  saturate( vec4  x ){ return clamp( x, vec4(0.0, 0.0, 0.0, 0.0), vec4(1.0, 1.0, 1.0, 1.0) ); }\n"
"\n"
"void sincos( float x, out float s, out float c ){ s = sin( x ); c = cos( x ); }\n"
"void sincos( vec2  x, out vec2  s, out vec2  c ){ s = sin( x ); c = cos( x ); }\n"
"void sincos( vec3  x, out vec3  s, out vec3  c ){ s = sin( x ); c = cos( x ); }\n"
"void sincos( vec4  x, out vec4  s, out vec4  c ){ s = sin( x ); c = cos( x ); }\n"
"\n"
"\n"
"// Bit conversion operations\n"
"\n"
"float asfloat( float x ){ return x; }\n"
"vec2  asfloat( vec2  x ){ return x; }\n"
"vec3  asfloat( vec3  x ){ return x; }\n"
"vec4  asfloat( vec4  x ){ return x; }\n"
"\n"
"float asfloat( int   x ){ return intBitsToFloat(x); }\n"
"vec2  asfloat( ivec2 x ){ return intBitsToFloat(x); }\n"
"vec3  asfloat( ivec3 x ){ return intBitsToFloat(x); }\n"
"vec4  asfloat( ivec4 x ){ return intBitsToFloat(x); }\n"
"\n"
"float asfloat( uint  x ){ return uintBitsToFloat(x); }\n"
"vec2  asfloat( uvec2 x ){ return uintBitsToFloat(x); }\n"
"vec3  asfloat( uvec3 x ){ return uintBitsToFloat(x); }\n"
"vec4  asfloat( uvec4 x ){ return uintBitsToFloat(x); }\n"
"\n"
"\n"
"int   asint( int   x ){ return x; }\n"
"ivec2 asint( ivec2 x ){ return x; }\n"
"ivec3 asint( ivec3 x ){ return x; }\n"
"ivec4 asint( ivec4 x ){ return x; }\n"
"\n"
"int   asint( uint  x ){ return int(x);   }\n"
"ivec2 asint( uvec2 x ){ return ivec2(x); }\n"
"ivec3 asint( uvec3 x ){ return ivec3(x); }\n"
"ivec4 asint( uvec4 x ){ return ivec4(x); }\n"
"\n"
"int   asint( float x ){ return floatBitsToInt(x); }\n"
"ivec2 asint( vec2  x ){ return floatBitsToInt(x); }\n"
"ivec3 asint( vec3  x ){ return floatBitsToInt(x); }\n"
"ivec4 asint( vec4  x ){ return floatBitsToInt(x); }\n"
"\n"
"\n"
"uint  asuint( uint  x ){ return x; }\n"
"uvec2 asuint( uvec2 x ){ return x; }\n"
"uvec3 asuint( uvec3 x ){ return x; }\n"
"uvec4 asuint( uvec4 x ){ return x; }\n"
"\n"
"uint  asuint( int  x  ){ return  uint(x); }\n"
"uvec2 asuint( ivec2 x ){ return uvec2(x); }\n"
"uvec3 asuint( ivec3 x ){ return uvec3(x); }\n"
"uvec4 asuint( ivec4 x ){ return uvec4(x); }\n"
"\n"
"uint  asuint( float x ){ return floatBitsToUint(x); }\n"
"uvec2 asuint( vec2  x ){ return floatBitsToUint(x); }\n"
"uvec3 asuint( vec3  x ){ return floatBitsToUint(x); }\n"
"uvec4 asuint( vec4  x ){ return floatBitsToUint(x); }\n"
"\n"
"\n"
"float f16tof32( uint u1 )\n"
"{ \n"
"    return unpackHalf2x16( u1 ).x; \n"
"}\n"
"vec2 f16tof32( uvec2 u2 )\n"
"{ \n"
"    uint u2PackedHalf = (u2.x & 0x0ffffu) | ((u2.y & 0x0ffffu) << 16u);\n"
"    return unpackHalf2x16( u2PackedHalf ); \n"
"}\n"
"vec3 f16tof32( uvec3 u3 )\n"
"{ \n"
"    return vec3( f16tof32( u3.xy ), f16tof32( u3.z ) );\n"
"}\n"
"vec4 f16tof32( uvec4 u4 )\n"
"{ \n"
"    return vec4( f16tof32( u4.xy ), f16tof32( u4.zw ) );\n"
"}\n"
"float f16tof32( int   i1 ){ return f16tof32( uint ( i1 ) ); }\n"
"vec2  f16tof32( ivec2 i2 ){ return f16tof32( uvec2( i2 ) ); }\n"
"vec3  f16tof32( ivec3 i3 ){ return f16tof32( uvec3( i3 ) ); }\n"
"vec4  f16tof32( ivec4 i4 ){ return f16tof32( uvec4( i4 ) ); }\n"
"\n"
"uint f32tof16( float f )\n"
"{ \n"
"    return packHalf2x16( vec2( f, 0.0 ) ) & 0x0ffffu; \n"
"}\n"
"uvec2 f32tof16( vec2 f2 )\n"
"{ \n"
"    uint u2PackedHalf = packHalf2x16( f2 );\n"
"    return uvec2( u2PackedHalf & 0x0ffffu, u2PackedHalf >> 16u );\n"
"}\n"
"uvec3 f32tof16( vec3 f3 )\n"
"{\n"
"    return uvec3( f32tof16( f3.xy ), f32tof16( f3.z ) );\n"
"}\n"
"uvec4 f32tof16( vec4 f4 )\n"
"{\n"
"    return uvec4( f32tof16( f4.xy ), f32tof16( f4.zw ) );\n"
"}\n"
"\n"
"#ifndef GL_ES // double is not supported on GLES\n"
"double asdouble(uint lowbits, uint highbits)\n"
"{\n"
"    return packDouble2x32( uvec2( lowbits, highbits ) );\n"
"}\n"
"#endif\n"
"\n"
"\n"
"// Floating point functions\n"
"\n"
"bool isfinite( float x )\n"
"{\n"
"    return !isinf( x ) && !isnan( x );\n"
"}\n"
"\n"
"bool2 isfinite( vec2 f2 )\n"
"{\n"
"    return bool2( isfinite( f2.x ), isfinite( f2.y ) );\n"
"}\n"
"\n"
"bool3 isfinite( vec3 f3 )\n"
"{\n"
"    return bool3( isfinite( f3.xy ), isfinite( f3.z ) );\n"
"}\n"
"\n"
"bool4 isfinite( vec4 f4 )\n"
"{\n"
"    return bool4( isfinite( f4.xyz ), isfinite( f4.w ) );\n"
"}\n"
"\n"
"#ifndef GL_ES\n"
"    float noise( float x ){ return noise1( x ); }\n"
"    vec2  noise( vec2  x ){ return noise2( x ); }\n"
"    vec3  noise( vec3  x ){ return noise3( x ); }\n"
"    vec4  noise( vec4  x ){ return noise4( x ); }\n"
"#else\n"
"    float noise( float x ){ return 0.0; }\n"
"    vec2  noise( vec2  x ){ return vec2(0.0, 0.0); }\n"
"    vec3  noise( vec3  x ){ return vec3(0.0, 0.0, 0.0); }\n"
"    vec4  noise( vec4  x ){ return vec4(0.0, 0.0, 0.0, 0.0); }\n"
"#endif\n"
"\n"
"float log10( float x )\n"
"{\n"
"    return log( x ) / log( 10.0 );\n"
"}\n"
"vec2 log10( vec2 x )\n"
"{\n"
"    float _lg10 = log( 10.0 );\n"
"    return log( x ) / vec2(_lg10, _lg10);\n"
"}\n"
"vec3 log10( vec3 x )\n"
"{\n"
"    float _lg10 = log( 10.0 );\n"
"    return log( x ) / vec3(_lg10, _lg10, _lg10);\n"
"}\n"
"vec4 log10( vec4 x )\n"
"{\n"
"    float _lg10 = log( 10.0 );\n"
"    return log( x ) / vec4(_lg10, _lg10, _lg10, _lg10);\n"
"}\n"
"\n"
"\n"
"#ifdef GL_ES\n"
"#   define mad(a,b,c) ((a)*(b)+(c))\n"
"#else\n"
"#   define mad fma\n"
"#endif\n"
"\n"
"\n"
"// Relational and logical operators\n"
"#define Less lessThan\n"
"#define LessEqual lessThanEqual\n"
"#define Greater greaterThan\n"
"#define GreaterEqual greaterThanEqual\n"
"#define Equal equal\n"
"#define NotEqual notEqual\n"
"#define Not not\n"
"bool4 And(bool4 L, bool4 R)\n"
"{\n"
"    return bool4(L.x && R.x,\n"
"                 L.y && R.y,\n"
"                 L.z && R.z,\n"
"                 L.w && R.w);\n"
"}\n"
"bool3 And(bool3 L, bool3 R)\n"
"{\n"
"    return bool3(L.x && R.x,\n"
"                 L.y && R.y,\n"
"                 L.z && R.z);\n"
"}\n"
"bool2 And(bool2 L, bool2 R)\n"
"{\n"
"    return bool2(L.x && R.x,\n"
"                 L.y && R.y);\n"
"}\n"
"bool And(bool L, bool R)\n"
"{\n"
"    return (L && R);\n"
"}\n"
"\n"
"\n"
"bool4 Or(bool4 L, bool4 R)\n"
"{\n"
"    return bool4(L.x || R.x,\n"
"                 L.y || R.y,\n"
"                 L.z || R.z,\n"
"                 L.w || R.w);\n"
"}\n"
"bool3 Or(bool3 L, bool3 R)\n"
"{\n"
"    return bool3(L.x || R.x,\n"
"                 L.y || R.y,\n"
"                 L.z || R.z);\n"
"}\n"
"bool2 Or(bool2 L, bool2 R)\n"
"{\n"
"    return bool2(L.x || R.x,\n"
"                 L.y || R.y);\n"
"}\n"
"bool Or(bool L, bool R)\n"
"{\n"
"    return (L || R);\n"
"}\n"
"\n"
"float4 BoolToFloat( bool4 b4 )\n"
"{\n"
"    return float4(b4.x ? 1.0 : 0.0,\n"
"                  b4.y ? 1.0 : 0.0,\n"
"                  b4.z ? 1.0 : 0.0,\n"
"                  b4.w ? 1.0 : 0.0);\n"
"}\n"
"float3 BoolToFloat( bool3 b3 )\n"
"{\n"
"    return float3(b3.x ? 1.0 : 0.0,\n"
"                  b3.y ? 1.0 : 0.0,\n"
"                  b3.z ? 1.0 : 0.0);\n"
"}\n"
"float2 BoolToFloat( bool2 b2 )\n"
"{\n"
"    return float2(b2.x ? 1.0 : 0.0,\n"
"                  b2.y ? 1.0 : 0.0);\n"
"}\n"
"float BoolToFloat( bool b )\n"
"{\n"
"    return b ? 1.0 : 0.0;\n"
"}\n"
"\n"
"\n"
"// Synchronization functions\n"
"\n"
"#ifdef COMPUTE_SHADER\n"
"\n"
"// https://www.opengl.org/wiki/Memory_Model#Incoherent_memory_access\n"
"\n"
"// MSDN: GroupMemoryBarrier() blocks execution of all threads \n"
"// in a group until all group SHARED accesses have been completed.\n"
"void GroupMemoryBarrier()\n"
"{\n"
"    // OpenGL.org: groupMemoryBarrier() waits on the completion of all memory accesses \n"
"    // performed by an invocation of a compute shader relative to the same access performed \n"
"    // by other invocations in the same work group and then returns with no other effect.\n"
"\n"
"    // groupMemoryBarrier() acts like memoryBarrier(), ordering memory writes for all kinds \n"
"    // of variables, but it only orders read/writes for the current work group.\n"
"    groupMemoryBarrier();\n"
"\n"
"    // OpenGL.org: memoryBarrierShared() waits on the completion of \n"
"    // all memory accesses resulting from the use of SHARED variables\n"
"    // and then returns with no other effect. \n"
"    memoryBarrierShared();\n"
"}\n"
"\n"
"// MSDN: GroupMemoryBarrierWithGroupSync() blocks execution of all \n"
"// threads in a group until all memory accesses have been completed \n"
"// and all threads in the group have reached this call.\n"
"void GroupMemoryBarrierWithGroupSync()\n"
"{\n"
"    // Issue memory barrier first!\n"
"    GroupMemoryBarrier();\n"
"    barrier();\n"
"}\n"
"\n"
"// MSDN: DeviceMemoryBarrier() blocks execution of all threads \n"
"// in a group until all device memory accesses have been completed.\n"
"void DeviceMemoryBarrier()\n"
"{\n"
"    // Call all memory barriers except for shared memory\n"
"    \n"
"    // Do we need to call groupMemoryBarrier() ????? \n"
"\n"
"    // OpenGL.org: memoryBarrierBuffer() waits on the completion of \n"
"    // all memory accesses resulting from the use of BUFFER variables \n"
"    // and then returns with no other effect\n"
"    memoryBarrierBuffer();\n"
"\n"
"    // OpenGL.org: memoryBarrierImage() waits on the completion of all \n"
"    // memory accesses resulting from the use of IMAGE variables and then \n"
"    // returns with no other effect. \n"
"    memoryBarrierImage();\n"
"\n"
"    // OpenGL.org: memoryBarrierAtomicCounter() waits on the completion of \n"
"    // all accesses resulting from the use of ATOMIC COUNTERS and then returns \n"
"    // with no other effect. \n"
"    memoryBarrierAtomicCounter();\n"
"}\n"
"\n"
"// MSDN: DeviceMemoryBarrierWithGroupSync() blocks execution of \n"
"// all threads in a group until all device memory accesses have \n"
"// been completed and all threads in the group have reached this call.\n"
"void DeviceMemoryBarrierWithGroupSync()\n"
"{\n"
"    DeviceMemoryBarrier();\n"
"    barrier();\n"
"}\n"
"\n"
"// MSDN: AllMemoryBarrier() blocks execution of all threads in a \n"
"// group until all memory accesses have been completed.\n"
"void AllMemoryBarrier()\n"
"{\n"
"    // OpenGL.org: memoryBarrier() waits on the completion of ALL \n"
"    // memory accesses resulting from the use of IMAGE variables or \n"
"    // ATOMIC COUNTERS and then returns with no other effect.\n"
"    memoryBarrier();\n"
"    // NOTE: nothing is said about buffer memory and shared memory,\n"
"    // so call memoryBarrierBuffer() and memoryBarrierShared() for safety\n"
"\n"
"    // OpenGL.org: memoryBarrierBuffer() waits on the completion of \n"
"    // all memory accesses resulting from the use of BUFFER variables \n"
"    // and then returns with no other effect\n"
"    memoryBarrierBuffer();\n"
"\n"
"    // OpenGL.org: memoryBarrierShared() waits on the completion of \n"
"    // all memory accesses resulting from the use of SHARED variables\n"
"    // and then returns with no other effect. \n"
"    memoryBarrierShared();\n"
"\n"
"    // Call all memory barrier functions. They should have no effect\n"
"    // if everything is synchronized.\n"
"    \n"
"    // OpenGL.org: memoryBarrierImage() waits on the completion of all \n"
"    // memory accesses resulting from the use of IMAGE variables and then \n"
"    // returns with no other effect. \n"
"    memoryBarrierImage();\n"
"\n"
"    // OpenGL.org: memoryBarrierAtomicCounter() waits on the completion of \n"
"    // all accesses resulting from the use of ATOMIC COUNTERS and then returns \n"
"    // with no other effect. \n"
"    memoryBarrierAtomicCounter();\n"
"\n"
"    // groupMemoryBarrier waits on the completion of all memory accesses performed \n"
"    // by an invocation of a compute shader relative to the same access performed by \n"
"    // other invocations in the same work group and then returns with no other effect.\n"
"    groupMemoryBarrier();\n"
"}\n"
"\n"
"// MSDN: AllMemoryBarrierWithGroupSync() blocks execution of all \n"
"// threads in a group until all memory accesses have been completed \n"
"// and all threads in the group have reached this call.\n"
"void AllMemoryBarrierWithGroupSync()\n"
"{\n"
"    AllMemoryBarrier();\n"
"    barrier();\n"
"}\n"
"\n"
"#else\n"
"\n"
"void AllMemoryBarrier(){}\n"
"void AllMemoryBarrierWithGroupSync(){}\n"
"void DeviceMemoryBarrier(){}\n"
"void DeviceMemoryBarrierWithGroupSync(){}\n"
"void GroupMemoryBarrier(){}\n"
"void GroupMemoryBarrierWithGroupSync(){}\n"
"\n"
"#endif\n"
"\n"
"\n"
"// Type conversion functions\n"
"\n"
"vec4 _ExpandVector( float x ){ return vec4(    x,    x,    x,    x ); }\n"
"vec4 _ExpandVector( vec2 f2 ){ return vec4( f2.x, f2.y,  0.0,  1.0 ); }\n"
"vec4 _ExpandVector( vec3 f3 ){ return vec4( f3.x, f3.y, f3.z,  1.0 ); }\n"
"vec4 _ExpandVector( vec4 f4 ){ return vec4( f4.x, f4.y, f4.z, f4.w ); }\n"
"\n"
"ivec4 _ExpandVector( int    x ){ return ivec4(    x,    x,    x,    x ); }\n"
"ivec4 _ExpandVector( ivec2 i2 ){ return ivec4( i2.x, i2.y,    0,    0 ); }\n"
"ivec4 _ExpandVector( ivec3 i3 ){ return ivec4( i3.x, i3.y, i3.z,    0 ); }\n"
"ivec4 _ExpandVector( ivec4 i4 ){ return ivec4( i4.x, i4.y, i4.z, i4.w ); }\n"
"\n"
"uvec4 _ExpandVector( uint   x ){ return uvec4(    x,    x,    x,    x ); }\n"
"uvec4 _ExpandVector( uvec2 u2 ){ return uvec4( u2.x, u2.y,   0u,   0u ); }\n"
"uvec4 _ExpandVector( uvec3 u3 ){ return uvec4( u3.x, u3.y, u3.z,   0u ); }\n"
"uvec4 _ExpandVector( uvec4 u4 ){ return uvec4( u4.x, u4.y, u4.z, u4.w ); }\n"
"\n"
"bvec4 _ExpandVector( bool   x ){ return bvec4(    x,    x,     x,     x ); }\n"
"bvec4 _ExpandVector( bvec2 b2 ){ return bvec4( b2.x, b2.y, false, false ); }\n"
"bvec4 _ExpandVector( bvec3 b3 ){ return bvec4( b3.x, b3.y,  b3.z, false ); }\n"
"bvec4 _ExpandVector( bvec4 b4 ){ return bvec4( b4.x, b4.y,  b4.z,  b4.w ); }\n"
"\n"
"\n"
"void _TypeConvertStore( out float Dst, in int   Src ){ Dst = float( Src ); }\n"
"void _TypeConvertStore( out float Dst, in uint  Src ){ Dst = float( Src ); }\n"
"void _TypeConvertStore( out float Dst, in float Src ){ Dst = float( Src ); }\n"
"void _TypeConvertStore( out uint  Dst, in int   Src ){ Dst = uint( Src ); }\n"
"void _TypeConvertStore( out uint  Dst, in uint  Src ){ Dst = uint( Src ); }\n"
"void _TypeConvertStore( out uint  Dst, in float Src ){ Dst = uint( Src ); }\n"
"void _TypeConvertStore( out int   Dst, in int   Src ){ Dst = int( Src ); }\n"
"void _TypeConvertStore( out int   Dst, in uint  Src ){ Dst = int( Src ); }\n"
"void _TypeConvertStore( out int   Dst, in float Src ){ Dst = int( Src ); }\n"
"\n"
"int _ToInt( int x )  { return int(x);       }\n"
"int _ToInt( uint x ) { return int(x);       }\n"
"int _ToInt( float x ){ return int(x);       }\n"
"int _ToInt( bool x ) { return x ? 1 : 0;    }\n"
"\n"
"float _ToFloat( int x )  { return float(x);     }\n"
"float _ToFloat( uint x ) { return float(x);     }\n"
"float _ToFloat( float x ){ return float(x);     }\n"
"float _ToFloat( bool x ) { return x ? 1.0 : 0.0;}\n"
"\n"
"uint _ToUint( int x )  { return uint(x);     }\n"
"uint _ToUint( uint x ) { return uint(x);     }\n"
"uint _ToUint( float x ){ return uint(x);     }\n"
"uint _ToUint( bool x ) { return x ? 1u : 0u; }\n"
"\n"
"bool _ToBool( int x )  { return x != 0   ? true : false; }\n"
"bool _ToBool( uint x ) { return x != 0u  ? true : false; }\n"
"bool _ToBool( float x ){ return x != 0.0 ? true : false; }\n"
"bool _ToBool( bool x ) { return x; }\n"
"\n"
"#define _ToVec2(x,y)     vec2(_ToFloat(x), _ToFloat(y))\n"
"#define _ToVec3(x,y,z)   vec3(_ToFloat(x), _ToFloat(y), _ToFloat(z))\n"
"#define _ToVec4(x,y,z,w) vec4(_ToFloat(x), _ToFloat(y), _ToFloat(z), _ToFloat(w))\n"
"\n"
"#define _ToIvec2(x,y)     ivec2(_ToInt(x), _ToInt(y))\n"
"#define _ToIvec3(x,y,z)   ivec3(_ToInt(x), _ToInt(y), _ToInt(z))\n"
"#define _ToIvec4(x,y,z,w) ivec4(_ToInt(x), _ToInt(y), _ToInt(z), _ToInt(w))\n"
"\n"
"#define _ToUvec2(x,y)     uvec2(_ToUint(x), _ToUint(y))\n"
"#define _ToUvec3(x,y,z)   uvec3(_ToUint(x), _ToUint(y), _ToUint(z))\n"
"#define _ToUvec4(x,y,z,w) uvec4(_ToUint(x), _ToUint(y), _ToUint(z), _ToUint(w))\n"
"\n"
"#define _ToBvec2(x,y)     bvec2(_ToBool(x), _ToBool(y))\n"
"#define _ToBvec3(x,y,z)   bvec3(_ToBool(x), _ToBool(y), _ToBool(z))\n"
"#define _ToBvec4(x,y,z,w) bvec4(_ToBool(x), _ToBool(y), _ToBool(z), _ToBool(w))\n"
"\n"
"\n"
"int   _ToIvec( uint  u1 ){ return _ToInt(   u1 ); }\n"
"ivec2 _ToIvec( uvec2 u2 ){ return _ToIvec2( u2.x, u2.y ); }\n"
"ivec3 _ToIvec( uvec3 u3 ){ return _ToIvec3( u3.x, u3.y, u3.z ); }\n"
"ivec4 _ToIvec( uvec4 u4 ){ return _ToIvec4( u4.x, u4.y, u4.z, u4.w ); }\n"
"\n"
"int   _ToIvec( int   i1 ){ return i1; }\n"
"ivec2 _ToIvec( ivec2 i2 ){ return i2; }\n"
"ivec3 _ToIvec( ivec3 i3 ){ return i3; }\n"
"ivec4 _ToIvec( ivec4 i4 ){ return i4; }\n"
"\n"
"int   _ToIvec( float f1 ){ return _ToInt(   f1 ); }\n"
"ivec2 _ToIvec( vec2  f2 ){ return _ToIvec2( f2.x, f2.y ); }\n"
"ivec3 _ToIvec( vec3  f3 ){ return _ToIvec3( f3.x, f3.y, f3.z ); }\n"
"ivec4 _ToIvec( vec4  f4 ){ return _ToIvec4( f4.x, f4.y, f4.z, f4.w ); }\n"
"\n"
"\n"
"float _ToVec( uint  u1 ){ return _ToFloat(u1); }\n"
"vec2  _ToVec( uvec2 u2 ){ return _ToVec2( u2.x, u2.y ); }\n"
"vec3  _ToVec( uvec3 u3 ){ return _ToVec3( u3.x, u3.y, u3.z ); }\n"
"vec4  _ToVec( uvec4 u4 ){ return _ToVec4( u4.x, u4.y, u4.z, u4.w ); }\n"
"         \n"
"float _ToVec( int   i1 ){ return _ToFloat(i1); }\n"
"vec2  _ToVec( ivec2 i2 ){ return _ToVec2( i2.x, i2.y ); }\n"
"vec3  _ToVec( ivec3 i3 ){ return _ToVec3( i3.x, i3.y, i3.z ); }\n"
"vec4  _ToVec( ivec4 i4 ){ return _ToVec4( i4.x, i4.y, i4.z, i4.w ); }\n"
"         \n"
"float _ToVec( float f1 ){ return f1; }\n"
"vec2  _ToVec( vec2  f2 ){ return f2; }\n"
"vec3  _ToVec( vec3  f3 ){ return f3; }\n"
"vec4  _ToVec( vec4  f4 ){ return f4; }\n"
"\n"
"\n"
"uint   _ToUvec( uint  u1 ){ return u1; }\n"
"uvec2  _ToUvec( uvec2 u2 ){ return u2; }\n"
"uvec3  _ToUvec( uvec3 u3 ){ return u3; }\n"
"uvec4  _ToUvec( uvec4 u4 ){ return u4; }\n"
"         \n"
"uint   _ToUvec( int   i1 ){ return _ToUint(  i1 ); }\n"
"uvec2  _ToUvec( ivec2 i2 ){ return _ToUvec2( i2.x, i2.y ); }\n"
"uvec3  _ToUvec( ivec3 i3 ){ return _ToUvec3( i3.x, i3.y, i3.z ); }\n"
"uvec4  _ToUvec( ivec4 i4 ){ return _ToUvec4( i4.x, i4.y, i4.z, i4.w ); }\n"
"         \n"
"uint   _ToUvec( float f1 ){ return _ToUint(  f1 ); }\n"
"uvec2  _ToUvec( vec2  f2 ){ return _ToUvec2( f2.x, f2.y ); }\n"
"uvec3  _ToUvec( vec3  f3 ){ return _ToUvec3( f3.x, f3.y, f3.z ); }\n"
"uvec4  _ToUvec( vec4  f4 ){ return _ToUvec4( f4.x, f4.y, f4.z, f4.w ); }\n"
"\n"
"\n"
"// TEXTURE FUNCTION STUB MACROS\n"
"// https://www.opengl.org/wiki/Sampler_(GLSL)\n"
"\n"
"\n"
"// Texture size queries\n"
"// https://www.opengl.org/sdk/docs/man/html/textureSize.xhtml\n"
"// textureSize returns the dimensions of level lod (if present) of the texture bound to sampler. \n"
"// The components in the return value are filled in, in order, with the width, height and depth \n"
"// of the texture. For the array forms, the last component of the return value is the number of \n"
"// layers in the texture array.\n"
"\n"
"//#if !(defined(DESKTOP_GL) && __VERSION__ >= 430)\n"
"#   define textureQueryLevels(x) 0 // Only supported on 4.3+\n"
"//#endif\n"
"\n"
"#define GetTex1DDimensions_1(Sampler, Width)\\\n"
"{                                                       \\\n"
"    _TypeConvertStore( Width, textureSize(Sampler, 0) );\\\n"
"}\n"
"\n"
"#define GetTex1DDimensions_3(Sampler, MipLevel, Width, NumberOfMipLevels)\\\n"
"{                                                                        \\\n"
"    _TypeConvertStore( Width, textureSize(Sampler, _ToInt(MipLevel)) );  \\\n"
"    _TypeConvertStore( NumberOfMipLevels, textureQueryLevels(Sampler) ); \\\n"
"}\n"
"\n"
"#define GetTex1DArrDimensions_2(Sampler, Width, Elements)\\\n"
"{                                           \\\n"
"    ivec2 i2Size = textureSize(Sampler, 0); \\\n"
"    _TypeConvertStore( Width,    i2Size.x );\\\n"
"    _TypeConvertStore( Elements, i2Size.y );\\\n"
"}\n"
"\n"
"#define GetTex1DArrDimensions_4(Sampler, MipLevel, Width, Elements, NumberOfMipLevels)\\\n"
"{                                                           \\\n"
"    ivec2 i2Size = textureSize(Sampler, _ToInt(MipLevel));  \\\n"
"    _TypeConvertStore( Width,    i2Size.x );                \\\n"
"    _TypeConvertStore( Elements, i2Size.y );                \\\n"
"    _TypeConvertStore( NumberOfMipLevels, textureQueryLevels(Sampler) );\\\n"
"}\n"
"\n"
"#define GetTex2DDimensions_2(Sampler, Width, Height)\\\n"
"{                                                   \\\n"
"    ivec2 i2Size = textureSize(Sampler, 0);         \\\n"
"    _TypeConvertStore( Width,  i2Size.x );          \\\n"
"    _TypeConvertStore( Height, i2Size.y );          \\\n"
"}\n"
"\n"
"#define GetTex2DDimensions_4(Sampler, MipLevel, Width, Height, NumberOfMipLevels)\\\n"
"{                                                           \\\n"
"    ivec2 i2Size = textureSize(Sampler, _ToInt(MipLevel) ); \\\n"
"    _TypeConvertStore( Width,  i2Size.x );                              \\\n"
"    _TypeConvertStore( Height, i2Size.y );                              \\\n"
"    _TypeConvertStore( NumberOfMipLevels, textureQueryLevels(Sampler) );\\\n"
"}\n"
"\n"
"#define GetTex2DArrDimensions_3(Sampler, Width, Height, Elements)\\\n"
"{                                           \\\n"
"    ivec3 i3Size = textureSize(Sampler, 0); \\\n"
"    _TypeConvertStore( Width,   i3Size.x ); \\\n"
"    _TypeConvertStore( Height,  i3Size.y ); \\\n"
"    _TypeConvertStore( Elements,i3Size.z ); \\\n"
"}\n"
"\n"
"#define GetTex2DArrDimensions_5(Sampler, MipLevel, Width, Height, Elements, NumberOfMipLevels)\\\n"
"{                                                           \\\n"
"    ivec3 i3Size = textureSize(Sampler, _ToInt(MipLevel));  \\\n"
"    _TypeConvertStore( Width,    i3Size.x );                            \\\n"
"    _TypeConvertStore( Height,   i3Size.y );                            \\\n"
"    _TypeConvertStore( Elements, i3Size.z );                            \\\n"
"    _TypeConvertStore( NumberOfMipLevels, textureQueryLevels(Sampler) );\\\n"
"}\n"
"\n"
"#define GetTex3DDimensions_3(Sampler, Width, Height, Depth)\\\n"
"{                                           \\\n"
"    ivec3 i3Size = textureSize(Sampler, 0); \\\n"
"    _TypeConvertStore( Width,  i3Size.x );  \\\n"
"    _TypeConvertStore( Height, i3Size.y );  \\\n"
"    _TypeConvertStore( Depth,  i3Size.z );  \\\n"
"}\n"
"\n"
"#define GetTex3DDimensions_5(Sampler, MipLevel, Width, Height, Depth, NumberOfMipLevels)\\\n"
"{                                                           \\\n"
"    ivec3 i3Size = textureSize(Sampler, _ToInt(MipLevel));  \\\n"
"    _TypeConvertStore( Width,  i3Size.x );                              \\\n"
"    _TypeConvertStore( Height, i3Size.y );                              \\\n"
"    _TypeConvertStore( Depth,  i3Size.z );                              \\\n"
"    _TypeConvertStore( NumberOfMipLevels, textureQueryLevels(Sampler) );\\\n"
"}\n"
"\n"
"#define GetTex2DMSDimensions_3(Sampler, Width, Height, NumberOfSamples)\\\n"
"{                                           \\\n"
"    ivec2 i2Size = textureSize(Sampler);    \\\n"
"    _TypeConvertStore( Width,  i2Size.x );  \\\n"
"    _TypeConvertStore( Height, i2Size.y );  \\\n"
"    _TypeConvertStore( NumberOfSamples, 0 );\\\n"
"}\n"
"\n"
"#define GetTex2DMSArrDimensions_4(Sampler, Width, Height, Elements, NumberOfSamples)\\\n"
"{                                           \\\n"
"    ivec3 i3Size = textureSize(Sampler);    \\\n"
"    _TypeConvertStore( Width,    i3Size.x );\\\n"
"    _TypeConvertStore( Height,   i3Size.y );\\\n"
"    _TypeConvertStore( Elements, i3Size.z );\\\n"
"    _TypeConvertStore( NumberOfSamples, 0 );\\\n"
"}\n"
"\n"
"\n"
"// https://www.opengl.org/sdk/docs/man/html/imageSize.xhtml\n"
"// imageSize returns the dimensions of the image bound to image. The components in the \n"
"// return value are filled in, in order, with the width, height and depth of the image. \n"
"// For the array forms, the last component of the return value is the number of layers \n"
"// in the texture array.\n"
"\n"
"#define GetRWTex1DDimensions_1(Tex, Width)\\\n"
"{                                               \\\n"
"    _TypeConvertStore( Width, imageSize(Tex) ); \\\n"
"}\n"
"\n"
"#define GetRWTex1DArrDimensions_2(Tex, Width, Elements)\\\n"
"{                                   \\\n"
"    ivec2 i2Size = imageSize(Tex);  \\\n"
"    _TypeConvertStore( Width,    i2Size.x ); \\\n"
"    _TypeConvertStore( Elements, i2Size.y ); \\\n"
"}\n"
"\n"
"#define GetRWTex2DDimensions_2(Tex, Width, Height)\\\n"
"{                                           \\\n"
"    ivec2 i2Size = imageSize(Tex);          \\\n"
"    _TypeConvertStore( Width,  i2Size.x );  \\\n"
"    _TypeConvertStore( Height, i2Size.y );  \\\n"
"}\n"
"\n"
"#define GetRWTex2DArrDimensions_3(Tex, Width, Height, Elements)\\\n"
"{                                           \\\n"
"    ivec3 i3Size = imageSize(Tex);          \\\n"
"    _TypeConvertStore( Width,    i3Size.x );\\\n"
"    _TypeConvertStore( Height,   i3Size.y );\\\n"
"    _TypeConvertStore( Elements, i3Size.z );\\\n"
"}\n"
"\n"
"#define GetRWTex3DDimensions_3(Tex, Width, Height, Depth)\\\n"
"{                                           \\\n"
"    ivec3 i3Size = imageSize(Tex);          \\\n"
"    _TypeConvertStore( Width,  i3Size.x );  \\\n"
"    _TypeConvertStore( Height, i3Size.y );  \\\n"
"    _TypeConvertStore( Depth,  i3Size.z );  \\\n"
"}\n"
"\n"
"\n"
"\n"
"// Texture sampling operations\n"
"\n"
"\n"
"//                             IMPORTANT NOTE ABOUT OFFSET\n"
"// Offset parameter to all texture sampling functions must be a constant expression.\n"
"// If it is not, the shader will be successfully compiled, HOWEVER the value of Offset \n"
"// will silently be zero. \n"
"//\n"
"// A constant expression in GLSL is defined as follows:\n"
"// * A literal value.\n"
"// * A const-qualified variable with an explicit initializer (so not a function parameter).\n"
"// * The result of the length() function of an array, but only if the array has an explicit size.\n"
"// * The result of most operators, so long as all the operands are themselves constant expressions. \n"
"//   The operators not on this list are any assignment operators (+= and so forth), and the comma operator.\n"
"// * The result of a constructor for a type, but only if all of the arguments to the constructor are \n"
"//   themselves constant expressions.\n"
"// * The return value of any built-in function, but only if all of the arguments to the function are \n"
"//   themselves constant expressions. Opaque Types are never constant expressions. Note that the \n"
"//   functions dFdx, dFdy, and fwidth will return 0, when used in a context that requires a constant \n"
"//   expression (such as a const variable initializer).\n"
"// \n"
"// The list above does not include return value of a function, even when the value is compile-time expression.\n"
"// As a result, we cannot use type conversion functions for Offset parameter.\n"
"\n"
"// In all texture sampling functions, the last component of Coords is used as Dsub and the array layer is specified \n"
"// in the second to last component of Coords. (The second component of Coords is unused for 1D shadow lookups.)\n"
"// For cube array textures, Dsub is specified as a separate parameter\n"
"//                                                                                                                                     mip\n"
"#define SampleCmpLevel0Tex1D_3(Tex, Sampler, Coords, CompareValue)      textureLod(Tex, _ToVec3((Coords).x,        0.0, CompareValue), 0.0)\n"
"#define SampleCmpLevel0Tex1DArr_3(Tex, Sampler, Coords, CompareValue)   textureLod(Tex, _ToVec3((Coords).x, (Coords).y, CompareValue), 0.0)\n"
"#define SampleCmpLevel0Tex2D_3(Tex, Sampler, Coords, CompareValue)      textureLod(Tex, _ToVec3((Coords).x, (Coords).y, CompareValue), 0.0)\n"
"#define SampleCmpLevel0Tex2DArr_3(Tex, Sampler, Coords, CompareValue)   0.0 // No textureLod for sampler2DArrayShadow\n"
"#define SampleCmpLevel0TexCube_3(Tex, Sampler, Coords, CompareValue)    0.0 // No textureLod for samplerCubeShadow\n"
"#define SampleCmpLevel0TexCubeArr_3(Tex, Sampler, Coords, CompareValue) 0.0 // No textureLod for samplerCubeArrayShadow\n"
"\n"
"//                                                                                                                                                 mip\n"
"#define SampleCmpLevel0Tex1D_4(Tex, Sampler, Coords, CompareValue, Offset)    textureLodOffset(Tex, _ToVec3((Coords).x,        0.0, CompareValue), 0.0, int(Offset))\n"
"#define SampleCmpLevel0Tex1DArr_4(Tex, Sampler, Coords, CompareValue, Offset) textureLodOffset(Tex, _ToVec3((Coords).x, (Coords).y, CompareValue), 0.0, int(Offset))\n"
"#define SampleCmpLevel0Tex2D_4(Tex, Sampler, Coords, CompareValue, Offset)    textureLodOffset(Tex, _ToVec3((Coords).x, (Coords).y, CompareValue), 0.0, ivec2((Offset).xy))\n"
"#define SampleCmpLevel0Tex2DArr_4(Tex, Sampler, Coords, CompareValue, Offset) 0.0 // No textureLodOffset for sampler2DArrayShadow\n"
"\n"
"\n"
"// https://www.opengl.org/sdk/docs/man/html/texture.xhtml - note: there are many mistakes on the page\n"
"#ifdef FRAGMENT_SHADER\n"
"\n"
"#   define Sample_2(Tex, Sampler, Coords)         texture      (Tex, _ToVec(Coords))\n"
"#   define Sample_3(Tex, Sampler, Coords, Offset) textureOffset(Tex, _ToVec(Coords), Offset)\n"
"#   define SampleBias_3(Tex, Sampler, Coords, Bias)         texture      (Tex, _ToVec(Coords), _ToFloat(Bias))\n"
"#   define SampleBias_4(Tex, Sampler, Coords, Bias, Offset) textureOffset(Tex, _ToVec(Coords), Offset, _ToFloat(Bias))\n"
"\n"
"#   define SampleCmpTex1D_3(Tex, Sampler, Coords, CompareValue)      texture(Tex, _ToVec3((Coords).x,        0.0, CompareValue))\n"
"#   define SampleCmpTex1DArr_3(Tex, Sampler, Coords, CompareValue)   texture(Tex, _ToVec3((Coords).x, (Coords).y, CompareValue))\n"
"#   define SampleCmpTex2D_3(Tex, Sampler, Coords, CompareValue)      texture(Tex, _ToVec3((Coords).x, (Coords).y, CompareValue))\n"
"#   define SampleCmpTex2DArr_3(Tex, Sampler, Coords, CompareValue)   texture(Tex, _ToVec4((Coords).x, (Coords).y, (Coords).z, CompareValue))\n"
"#   define SampleCmpTexCube_3(Tex, Sampler, Coords, CompareValue)    texture(Tex, _ToVec4((Coords).x, (Coords).y, (Coords).z, CompareValue))\n"
"#   define SampleCmpTexCubeArr_3(Tex, Sampler, Coords, CompareValue) texture(Tex, _ToVec4((Coords).x, (Coords).y, (Coords).z, (Coords).w), _ToFloat(CompareValue))\n"
"\n"
"#   define SampleCmpTex1D_4(Tex, Sampler, Coords, CompareValue, Offset)    textureOffset(Tex, _ToVec3((Coords).x,        0.0, CompareValue), int(Offset))\n"
"#   define SampleCmpTex1DArr_4(Tex, Sampler, Coords, CompareValue, Offset) textureOffset(Tex, _ToVec3((Coords).x, (Coords).y, CompareValue), int(Offset))\n"
"#   define SampleCmpTex2D_4(Tex, Sampler, Coords, CompareValue, Offset)    textureOffset(Tex, _ToVec3((Coords).x, (Coords).y, CompareValue), ivec2((Offset).xy))\n"
"#   define SampleCmpTex2DArr_4(Tex, Sampler, Coords, CompareValue, Offset) textureOffset(Tex, _ToVec4((Coords).x, (Coords).y, (Coords).z, CompareValue), ivec2((Offset).xy))\n"
"\n"
"#else\n"
"\n"
"// Derivatives are only available in fragment shader. GLSL compiler fails when it\n"
"// encounters texture() or textureOffset() instructions in other types of shaders. So\n"
"// to let the shader be compiled and to have something meaningful, replace such operations\n"
"// with textureLod() and textureLodOffset()\n"
"\n"
"#   define Sample_2(Tex, Sampler, Coords)         textureLod      (Tex, _ToVec(Coords), 0.0)\n"
"#   define Sample_3(Tex, Sampler, Coords, Offset) textureLodOffset(Tex, _ToVec(Coords), 0.0, Offset)\n"
"#   define SampleBias_3(Tex, Sampler, Coords, Bias)         textureLod      (Tex, _ToVec(Coords), 0.0 + _ToFloat(Bias))\n"
"#   define SampleBias_4(Tex, Sampler, Coords, Bias, Offset) textureLodOffset(Tex, _ToVec(Coords), 0.0 + _ToFloat(Bias), Offset)\n"
"\n"
"#   define SampleCmpTex1D_3        SampleCmpLevel0Tex1D_3\n"
"#   define SampleCmpTex1DArr_3     SampleCmpLevel0Tex1DArr_3\n"
"#   define SampleCmpTex2D_3        SampleCmpLevel0Tex2D_3\n"
"#   define SampleCmpTex2DArr_3     SampleCmpLevel0Tex2DArr_3\n"
"#   define SampleCmpTexCube_3      SampleCmpLevel0TexCube_3\n"
"#   define SampleCmpTexCubeArr_3   SampleCmpLevel0TexCubeArr_3\n"
"                                            \n"
"#   define SampleCmpTex1D_4        SampleCmpLevel0Tex1D_4\n"
"#   define SampleCmpTex1DArr_4     SampleCmpLevel0Tex1DArr_4\n"
"#   define SampleCmpTex2D_4        SampleCmpLevel0Tex2D_4\n"
"#   define SampleCmpTex2DArr_4     SampleCmpLevel0Tex2DArr_4\n"
"\n"
"#endif\n"
"\n"
"// https://www.opengl.org/sdk/docs/man/html/textureLod.xhtml\n"
"#define SampleLevel_3(Tex, Sampler, Coords, Level)         textureLod      (Tex, _ToVec(Coords), _ToFloat(Level))\n"
"#define SampleLevel_4(Tex, Sampler, Coords, Level, Offset) textureLodOffset(Tex, _ToVec(Coords), _ToFloat(Level), Offset)\n"
"\n"
"// https://www.opengl.org/sdk/docs/man/html/textureGrad.xhtml\n"
"#define SampleGrad_4(Tex, Sampler, Coords, DDX, DDY)         textureGrad      (Tex, _ToVec(Coords), _ToVec(DDX), _ToVec(DDY))\n"
"#define SampleGrad_5(Tex, Sampler, Coords, DDX, DDY, Offset) textureGradOffset(Tex, _ToVec(Coords), _ToVec(DDX), _ToVec(DDY), Offset)\n"
"\n"
"\n"
"// texelFetch performs a lookup of a single texel from texture coordinate P in the texture \n"
"// bound to sampler. The array layer is specified in the last component of P for array forms. \n"
"// The lod parameter (if present) specifies the level-of-detail from which the texel will be fetched. \n"
"// The sample specifies which sample within the texel will be returned when reading from a multi-sample texure.\n"
"\n"
"#define LoadTex1D_1(Tex, Location)        texelFetch      (Tex, _ToInt((Location).x), _ToInt((Location).y))\n"
"#define LoadTex1D_2(Tex, Location, Offset)texelFetchOffset(Tex, _ToInt((Location).x), _ToInt((Location).y), int(Offset))\n"
"#define LoadTex1DArr_1(Tex, Location)        texelFetch      (Tex, _ToIvec( (Location).xy), _ToInt((Location).z) )\n"
"#define LoadTex1DArr_2(Tex, Location, Offset)texelFetchOffset(Tex, _ToIvec( (Location).xy), _ToInt((Location).z), int(Offset))\n"
"#define LoadTex2D_1(Tex, Location)        texelFetch      (Tex, _ToIvec( (Location).xy), _ToInt((Location).z))\n"
"#define LoadTex2D_2(Tex, Location, Offset)texelFetchOffset(Tex, _ToIvec( (Location).xy), _ToInt((Location).z), ivec2( (Offset).xy) )\n"
"#define LoadTex2DArr_1(Tex, Location)        texelFetch      (Tex, _ToIvec( (Location).xyz), _ToInt((Location).w) )\n"
"#define LoadTex2DArr_2(Tex, Location, Offset)texelFetchOffset(Tex, _ToIvec( (Location).xyz), _ToInt((Location).w), ivec2( (Offset).xy))\n"
"#define LoadTex3D_1(Tex, Location)        texelFetch      (Tex, _ToIvec( (Location).xyz), _ToInt((Location).w))\n"
"#define LoadTex3D_2(Tex, Location, Offset)texelFetchOffset(Tex, _ToIvec( (Location).xyz), _ToInt((Location).w), ivec3( (Offset).xyz))\n"
"#define LoadTex2DMS_2(Tex, Location, Sample)        texelFetch(Tex, _ToIvec( (Location).xy), _ToInt(Sample))\n"
"#define LoadTex2DMS_3(Tex, Location, Sample, Offset)texelFetch(Tex, _ToIvec2( (Location).x + (Offset).x, (Location).y + (Offset).y), int(Sample) ) // No texelFetchOffset for texture2DMS\n"
"#define LoadTex2DMSArr_2(Tex, Location, Sample)        texelFetch(Tex, _ToIvec( (Location).xyz), _ToInt(Sample))\n"
"#define LoadTex2DMSArr_3(Tex, Location, Sample, Offset)texelFetch(Tex, _ToIvec3( (Location).x + (Offset).x, (Location).y + (Offset).y, (Location).z), int(Sample)) // No texelFetchOffset for texture2DMSArray\n"
"\n"
"//https://www.opengl.org/sdk/docs/man/html/imageLoad.xhtml\n"
"#define LoadRWTex1D_1(Tex, Location)    imageLoad(Tex, _ToIvec((Location).x)   )\n"
"#define LoadRWTex1DArr_1(Tex, Location) imageLoad(Tex, _ToIvec((Location).xy)  )\n"
"#define LoadRWTex2D_1(Tex, Location)    imageLoad(Tex, _ToIvec((Location).xy)  )\n"
"#define LoadRWTex2DArr_1(Tex, Location) imageLoad(Tex, _ToIvec((Location).xyz) )\n"
"#define LoadRWTex3D_1(Tex, Location)    imageLoad(Tex, _ToIvec((Location).xyz) )\n"
"\n"
"\n"
"#define Gather_2(Tex, Sampler, Location)        textureGather      (Tex, _ToVec(Location))\n"
"#define Gather_3(Tex, Sampler, Location, Offset)textureGatherOffset(Tex, _ToVec(Location), Offset)\n"
"\n"
"#define GatherCmp_3(Tex, Sampler, Location, CompareVal)        textureGather      (Tex, _ToVec(Location), _ToFloat(CompareVal))\n"
"#define GatherCmp_4(Tex, Sampler, Location, CompareVal, Offset)textureGatherOffset(Tex, _ToVec(Location), _ToFloat(CompareVal), Offset)\n"
"\n"
"// Atomic operations\n"
"#define InterlockedAddSharedVar_2(dest, value)                      atomicAdd(dest, value)\n"
"#define InterlockedAddSharedVar_3(dest, value, orig_val) orig_val = atomicAdd(dest, value)\n"
"#define InterlockedAddImage_2(img, coords, value)                     imageAtomicAdd(img, _ToIvec(coords), value)\n"
"#define InterlockedAddImage_3(img, coords, value, orig_val)orig_val = imageAtomicAdd(img, _ToIvec(coords), value)\n"
"\n"
"#define InterlockedAndSharedVar_2(dest, value)                      atomicAnd(dest, value)\n"
"#define InterlockedAndSharedVar_3(dest, value, orig_val) orig_val = atomicAnd(dest, value)\n"
"#define InterlockedAndImage_2(img, coords, value)                     imageAtomicAnd(img, _ToIvec(coords), value)\n"
"#define InterlockedAndImage_3(img, coords, value, orig_val)orig_val = imageAtomicAnd(img, _ToIvec(coords), value)\n"
"\n"
"#define InterlockedMaxSharedVar_2(dest, value)                      atomicMax(dest, value)\n"
"#define InterlockedMaxSharedVar_3(dest, value, orig_val) orig_val = atomicMax(dest, value)\n"
"#define InterlockedMaxImage_2(img, coords, value)                     imageAtomicMax(img, _ToIvec(coords), value)\n"
"#define InterlockedMaxImage_3(img, coords, value, orig_val)orig_val = imageAtomicMax(img, _ToIvec(coords), value)\n"
"\n"
"#define InterlockedMinSharedVar_2(dest, value)                      atomicMin(dest, value)\n"
"#define InterlockedMinSharedVar_3(dest, value, orig_val) orig_val = atomicMin(dest, value)\n"
"#define InterlockedMinImage_2(img, coords, value)                     imageAtomicMin(img, _ToIvec(coords), value)\n"
"#define InterlockedMinImage_3(img, coords, value, orig_val)orig_val = imageAtomicMin(img, _ToIvec(coords), value)\n"
"\n"
"#define InterlockedOrSharedVar_2(dest, value)                      atomicOr(dest, value)\n"
"#define InterlockedOrSharedVar_3(dest, value, orig_val) orig_val = atomicOr(dest, value)\n"
"#define InterlockedOrImage_2(img, coords, value)                     imageAtomicOr(img, _ToIvec(coords), value)\n"
"#define InterlockedOrImage_3(img, coords, value, orig_val)orig_val = imageAtomicOr(img, _ToIvec(coords), value)\n"
"\n"
"#define InterlockedXorSharedVar_2(dest, value)                      atomicXor(dest, value)\n"
"#define InterlockedXorSharedVar_3(dest, value, orig_val) orig_val = atomicXor(dest, value)\n"
"#define InterlockedXorImage_2(img, coords, value)                     imageAtomicXor(img, _ToIvec(coords), value)\n"
"#define InterlockedXorImage_3(img, coords, value, orig_val)orig_val = imageAtomicXor(img, _ToIvec(coords), value)\n"
"\n"
"// There is actually no InterlockedExchange() with 2 arguments\n"
"#define InterlockedExchangeSharedVar_2(dest, value)                      atomicExchange(dest, value)\n"
"#define InterlockedExchangeSharedVar_3(dest, value, orig_val) orig_val = atomicExchange(dest, value)\n"
"#define InterlockedExchangeImage_2(img, coords, value)                     imageAtomicExchange(img, _ToIvec(coords), value)\n"
"#define InterlockedExchangeImage_3(img, coords, value, orig_val)orig_val = imageAtomicExchange(img, _ToIvec(coords), value)\n"
"\n"
"//uint imageAtomicCompSwap(	image img,    IVec P,       nint compare,   nint data);\n"
"//void InterlockedCompareExchange(     in R dest, in T compare_value, in  T value, out T original_value);\n"
"#define InterlockedCompareExchangeSharedVar_4(dest, cmp_val, value, orig_val)  orig_val = atomicCompSwap(dest, cmp_val, value)\n"
"#define InterlockedCompareExchangeImage_4(img, coords, cmp_val, value, orig_val) orig_val = imageAtomicCompSwap(img, _ToIvec(coords), cmp_val, value)\n"
"\n"
"#define InterlockedCompareStoreSharedVar_3(dest, cmp_val, value) atomicCompSwap(dest, cmp_val, value)\n"
"#define InterlockedCompareStoreImage_3(img, coords, cmp_val, value)imageAtomicCompSwap(img, _ToIvec(coords), cmp_val, value)\n"
"\n"
"\n"
"// Swizzling macros\n"
"#define _SWIZZLE0\n"
"#define _SWIZZLE1 .x\n"
"#define _SWIZZLE2 .xy\n"
"#define _SWIZZLE3 .xyz\n"
"#define _SWIZZLE4 .xyzw\n"
"\n"
"// Helper functions\n"
"\n"
"float2 NormalizedDeviceXYToTexUV( float2 f2ProjSpaceXY )\n"
"{\n"
"    return float2(0.5,0.5) + float2(0.5,0.5) * f2ProjSpaceXY.xy;\n"
"}\n"
"\n"
"float NormalizedDeviceZToDepth(float fNDC_Z)\n"
"{\n"
"    return fNDC_Z * 0.5 + 0.5; // [-1, +1] -> [0, 1]\n"
"}\n"
"\n"
"float DepthToNormalizedDeviceZ(float fDepth)\n"
"{\n"
"    return fDepth * 2.0 - 1.0; // [0, 1] -> [-1, +1]\n"
"}\n"
"\n"
"#define F3NDC_XYZ_TO_UVD_SCALE float3(0.5, 0.5, 0.5)\n"
"\n"
"#define NDC_MIN_Z -1.0 // Minimal z in the normalized device space\n"
"\n"
"#define MATRIX_ELEMENT(mat, row, col) mat[col][row]\n"
"\n"
"#endif // _GLSL_DEFINITIONS_\n"
